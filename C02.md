## Building the Gnu GCC toolchain
The standard Gnu-GCC toolchain of compilation is required in order to build many of the applications that have to run on the RISCV64 machine and to properly build the *BusyBox* component, which is a single binary wrapping all the main Linux commands used on a standard system. Busybox represents a good choice to start managing an emulated system, without the large overhead of installing an entire (full-fledged) operating system. In the following, the few steps necessary to install the GCC toolchain are reported. Once createdm, this toolchain allows the cross-compilation of code targeting the RISCV64 machines (this should include the suport to various ISA extensions), and so, it can be copied on the targeted (emulated) system.
1. Install all the prerequisite (host system libraries and packages):
```
    $ sudo apt update && sudo apt upgrade 
    $ sudo apt install ncurses-devel ncurses autoconf automake autotools-dev curl python3 libmpc-dev libmpfr-dev libgmp-dev gawk build-essential bison flex texinfo gperf libtool patchutils bc zlib1g-dev libexpat-dev
``` 
2. Cloning the Gnu-GCC toolchain repository (supposing to be in the host directory under which the toolchain should be built --e.g., being in the directory `/home/$USER/riscv64` the following command will clone in the repository in the `/home/$USER/riscv64/riscv-gnu-toolchain` folder the source code):
```bash
    $ cd <toolchain-target-folder>
    $ git clone --recursive https://github.com/riscv/riscv-gnu-toolchain
```
3. Entering the cloned repository and built it:
```bash
    $ cd riscv-gnu-toolchain
    $ mkdir install
    $ ./configure --prefix=$(pwd)/install
    $ make linux -j $(nproc)
```
Under the `<path-to-riscv-gnu-toolchain>/install/bin` there are the built binaries; possibly, they can be sourced by patching the PATH environmental variable.

## Building Busybox
*Busybox* is a flexible software that provides a large number of Linux commands all together packed into a single binary. This makes Busybox a very powerfull toolbox for embedded systems as well as for emulated nodes that do not require a full-fledged operating system. As such, Busybox is a good option for starting with developments of applications without the overhead of an operating system. In the following, the steps for creating the Busybox binary are provided:
1. Cloning the repository and checking out the latest stable version (to this end, check the official [Busybox](https://busybox.net) website)[^1]:
```bash
    $ git clone https://git.busybox.net/busybox
    $ cd busybox
    $ git checkout 1_36_1
```
2. Configuring the GCC toolbox for cross-compiling the busybox binary. As such, the target architecture is set to RISCV64. The second command allows to setting Busybox to be built linking with static libraries (the commend open a curl graphical menu):
```bash
    $ make ARCH=riscv64 CROSS_COMPILE=riscv64-unknown-linux-gnu- defconfig
    $ make ARCH=riscv64 CROSS_COMPILE=riscv64-unknown-linux-gnu- menuconfig
```
On the graphical menu, select `Settings` and search inside the Build Options `Build BusyBox as a static binary (no shared libs)` &rarr; `Yes`[^2]. Press ESC twice to save the configuratio and exit.
3. Cross-compiling the binary:
```bash
    $ make ARCH=riscv64 CROSS_COMPILE=riscv64-unknown-linux-gnu- -j $(nproc)
    $ mkdir bin 
    $ make CONFIG_PREFIX=$(pwd)/bin install
```
Within the `<busybox-folder-path>/bin` folder, the binary with the soft links wrapping Linux command is created.  

[^1]: At the moment of writing this document the latest stable version is the 1.36.1.
[^2]: In some case, a star symbol can be switched on/off for the specific options.

## Emulating a small RISCV-64 machine 
At this point, almost all the components needed to emulate a small RISCV-64 node are setup. The only missing part is to create the INITRAMFS, which is a RAM disk containing the filesystem tree and Busybox to run. The following steps provide a way to create a minimalistic INITRAMFS.
1. Creating the tree structure:
```bash 
    $ mkdir initramfs
    $ cd initramfs
    $ mkdir -p {bin,sbin,dev,etc,home,mnt,proc,sys,usr,tmp}
    $ mkdir -p usr/{bin,sbin}
    $ mkdir -p proc/sys/kernel
    $ mkdir -p usr/local
    $ mkdir -p usr/local/go
```
The last two lines create the folder which will contain the go compiler we created in the [Chapter 1](https://github.com/francesco-ismb/LINKS-RISC-V-Cloud-Computing-Ecosystem/blob/main/C01.md).
2. Setting the device folder:
```bash
    $ cd dev
    $ sudo mknod sda b 8 0 && sudo mknod console c 5 1
    $ cd ..
```
3. Copying Busybox and Golang compiler in the proper folders
```bash
    $ cp <path-to-busybox-binary>/busybox ./bin/ 
    $ cp <path-to-go-binaries>/* ./usr/local/go/
```