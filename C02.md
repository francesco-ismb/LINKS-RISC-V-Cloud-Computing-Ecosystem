## Building the Gnu GCC toolchain
The standard Gnu-GCC toolchain of compilation is required in order to build many of the applications that have to run on the RISCV64 machine and to properly build the *BusyBox* component, which is a single binary wrapping all the main Linux commands used on a standard system. Busybox represents a good choice to start managing an emulated system, without the large overhead of installing an entire (full-fledged) operating system. In the following, the few steps necessary to install the GCC toolchain are reported. Once createdm, this toolchain allows the cross-compilation of code targeting the RISCV64 machines (this should include the suport to various ISA extensions), and so, it can be copied on the targeted (emulated) system.
1. Install all the prerequisite (host system libraries and packages):
```
    $ sudo apt update && sudo apt upgrade 
    $ sudo apt install ncurses-devel ncurses autoconf automake autotools-dev curl python3 libmpc-dev libmpfr-dev libgmp-dev gawk build-essential bison flex texinfo gperf libtool patchutils bc zlib1g-dev libexpat-dev
``` 
2. Cloning the Gnu-GCC toolchain repository (supposing to be in the host directory under which the toolchain should be built --e.g., being in the directory `/home/$USER/riscv64` the following command will clone in the repository in the `/home/$USER/riscv64/riscv-gnu-toolchain` folder the source code):
```bash
    $ cd <toolchain-target-folder>
    $ git clone --recursive https://github.com/riscv/riscv-gnu-toolchain
```
3. Entering the cloned repository and built it:
```bash
    $ cd riscv-gnu-toolchain
    $ mkdir install
    $ ./configure --prefix=$(pwd)/install
    $ make linux -j $(nproc)
```
Under the `<path-to-riscv-gnu-toolchain>/install/bin` there are the built binaries; possibly, they can be sourced by patching the PATH environmental variable.

## Building Busybox
*Busybox* is a flexible software that provides a large number of Linux commands all together packed into a single binary. This makes Busybox a very powerfull toolbox for embedded systems as well as for emulated nodes that do not require a full-fledged operating system. As such, Busybox is a good option for starting with developments of applications without the overhead of an operating system. In the following, the steps for creating the Busybox binary are provided:
1. Cloning the repository and checking out the latest stable version (to this end, check the official [Busybox](https://busybox.net) website)[^1]:
```bash
    $ git clone https://git.busybox.net/busybox
    $ cd busybox
    $ git checkout 1_36_1
```

2. Configuring the GCC toolbox for cross-compiling the busybox binary. As such, the target architecture is set to RISCV64. Worth to mention is that it could be necessary to create on the installation directory of the riscv toolchain soft links to the binaries in such a way they could be called as `riscv64-linux-gnu-`, which is called by some of the scripts called during the compilation process. For instance, mapping GCC is done as `$ln -s <installation_dir>/riscv64-unknown-linux-gnu-gcc riscv64-linux-gnu-gcc`. The following steps configure and compile the busybox binary:
```bash
    $ CROSS_COMPILE=riscv64-unknown-linux-gnu- LDFLAGS=--static make defconfig
```
The 'LDFLAG' option instructs the compiler to create a binary with the static link to shared libraries. This is mandatory in order to use the BusyBox binary as a base for building a minimal basic image.   

3. Cross-compiling the binary:
```bash
    $ CROSS_COMPILE=riscv64-unknown-linux-gnu- LDFLAGS=--static make -j$(nproc)
    $ mkdir bin
    $ CROSS_COMPILE=riscv64-unknown-linux-gnu- LDFLAGS=--static make -C ./ install CONFIG_PREFIX=$(pwd)/bin
```
Within the `<busybox-folder-path>/bin` folder, the binary with the soft links wrapping Linux command is created.  

[^1]: At the moment of writing this document the latest stable version is the 1.36.1.
[^2]: In some case, a star symbol can be switched on/off for the specific options.

## Building the Linux kernel
At this point it is necessary to clone and compile the Linux kernel image. To this end, the official Torval repository is targeted (this takes a while since the entire repository occupies around 4.31 GiB). The following steps provide the details:
1. Cloning the repository (at the moment of writing this guide, the latest stable version is marked as `v5.19`; however, from the online repository the reader can check the latest available version):
```bash
    $ git clone https://github.com/torvalds/linux
    $ cd linux
    $ git checkout v5.19
```
2. Configuring the directory to for compilation:
```bash 
    $ make ARCH=riscv CROSS_COMPILE=riscv64-unknown-linux-gnu- defconfig
```
3. Compiling the kernel image:
```bash    
    $ make ARCH=riscv CROSS_COMPILE=riscv64-unknown-linux-gnu- -j $(nproc)
```

## Emulating a small RISCV-64 machine 
At this point, almost all the components needed to emulate a small RISCV-64 node are setup. The only missing part is to create a small virtual disk containing the Root filesystem (ROOTFS) required to boot the machine. This can be done by creating a virtual empty disk (the size can be set as 512MiB), formatting it with a standard filesystem (see chapter [1](https://github.com/francesco-ismb/LINKS-RISC-V-Cloud-Computing-Ecosystem/blob/main/C01.md) also), and creating a minimalistic folders tree. Once done with this steps, we will create the proper 'init' script (i.e., `/etc/init.d/rcS`) which is the one used by the kernel to complete the boot sequence. 
1. Creating the virtual empty disk (to this end, differently from the steps used in chapter 1, we use a default Linux command, since we do not need to manipulate the disk after):
```bash 
    $ dd if=/dev/zero of=<path-to-storage>/basic.img bs=1M count=512
```
At the end of this command, a new file called `basic.img` of 512MiB all zeroed has been created.
2. The newly created disk is going to be formatted (EXT4 is the filesystem type used for this operation):
```bash
    $ cd <path-to-storage>
    $ mkfs.ext4 basic.img
    $ mkdir rootfs
    $ sudo mount -t ext4 basic.img rootfs/ 
```
The last command mounts the disk on the temporary created folder 'rootfs'.
3. Installing the BusyBox toolbox on the mounted filesystem:
```bash
    $ sudo CROSS_COMPILE=riscv64-linux-gnu- LDFLAGS=--static make -C <path-to-busybox-root>/ install CONFIG_PREFIX=$(pwd)/rootfs/
```
4. Creating few basic directories, and ensure the that `/etc/fstab` exists to avoid warnings during the boot-up process. Finally, create the `init.d` folder to install properly the initial boot-up script:
```bash
    $ sudo mkdir -p ./rootfs/proc ./rootfs/sys ./rootfs/dev
    $ sudo mkdir -p ./rootfs/etc
    $ sudo touch ./rootfs/etc/fstab
    $ sudo mkdir -p ./rootfs/etc/init.d
```
5. Create the boot-up script used by the kernel to complete the boot-up process:
```bash 
    $ sudo vim ./rootfs/etc/init.d/rcS
    #!/bin/sh
    
    echo
    echo
    echo "Hello Embedded World!"
    echo "Hello RISC-V World!"
    echo 
    echo
    mount -t proc proc /proc
    mount -t sysfs sysfs /sys
    ip addr add 10.0.2.15/24 dev eth0
    ip link set dev eth0 up
    ip route add default via 10.0.2.2 dev eth0
```
6. Finally, make the script executable and then unmount the created folder tree and make the virtual disk available for booting the virtual machine:
```bash
    $ sudo chmod +x ./rootfs/etc/init.d/rcS
    $ sudo umount rootfs
    $ rm -rf rootfs
```

Make the script executable by executing `$chmod +x init` and finally create the *initramfs* file:
```bash
    $ find . -print0 | cpio --null -ov --format=newc | gzip -9 > initramfs.cpio.gz
```

### Running the emulated RISCV64 machine
An emulated node can be spinned up by calling the `qemu-system-<arch>` binary and passing to it a set of specific options which define how the emulated node should appear, which is the kernel image to run and potentially attaching a permanent storage. The targeted architecture in our case is the RISCV64, so, the options can be passed to the binary on the command line. For our convenience, we can also set up a bash script, and make it executable as follows (we call it **run-basic.sh**): 
```bash
    #! /bin/bash
    
    # Environmental variable 
    PLATFORM="virt"
    KERNEL_IMG="../../tools/linux/arch/riscv/boot/Image"
    MAIN_DRIVE="../../storage/basic.img"
    MEM="512M"
    SMP=1
    
    # Launching the machine
    qemu-system-riscv64 -machine ${PLATFORM} \
                    -smp ${SMP} \
                    -m ${MEM} \
                    -kernel ${KERNEL_IMG} \
                    -append "root=/dev/vda rw console=ttyS0" \
                    -drive file=${MAIN_DRIVE},format=raw,id=hdd0 \
                    -device virtio-blk-device,drive=hdd0 \
                    -netdev user,id=eth0,hostfwd=tcp::8022-:22 
                    -device virtio-net-device,netdev=eth0 \
                    -nographic
```
The script can be made executable by issuing the `chmod +x run-basic.sh`. Important notes are the following ones:
- The running script makes use of variables to define the relative position of the files (i.e., kernel image, main drive containing the root filesystem) as well as parameter for the emulated machine (i.e., type of platform to emulate, the RAM memory to allocate, the number of CPU cores to emulate). These variables **must be redefined** according to the user environment.
- The networking is enabled through the previously compiled slirp extension; in the emulated machine, the network (as well as other devices) is declared to be instantiated through two lines:
    1. The follwong line declare a network device (`-netdev`) for which the `user` backend (there are many possible differen backends supported by Qemu; the user one basically emulates the full TCP/IP stack; so, it does not provide the highest possible performance) is specified. Then, an `id=eth0` is assigned to the device; finally, it is required to forward the (TCP) traffic from the port 8022 on the host to the port 22 of the emulated device.  
```bash 
   -netdev user,id=eth0,hostfwd=tcp::8022-:22 
```
    2. This line associates the previously defined device (`id=eth0`) to the internal virtual-io network device of Qemu (`virtio-net-device`).  
```bash 
   -device virtio-net-device,netdev=eth0 
``` 
<!---
The following URLs provide instructions for creating an initial Root-FS (RFS) with a minimal init process
https://hackmd.io/@starnight/Busbox_as_the_init
https://www.praghadeesh.com/building-a-minimal-linux-with-busybox/
https://devpress.csdn.net/linux/62fa44a37e6682346618e0d7.html
--->
